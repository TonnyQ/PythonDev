#1.Master-Worker模式：Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker
#如果用多进程实现Master-Worker，主进程就是Master，其他进程为worker
#如果采用多线程实现Master-Worker，主线程就是Master，其他线程为Worker

#多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响到主进程和其他子进程，但是如果主进程都挂掉了，
#那么所有的子进程都将终止。例如Apache就是采用的这种模式。

#多进程模式最大的缺点是创建进程的代价大，在Unix、Linux系统下，用fork调用还行，在window下创建进程的开销巨大。
#另外，操作系统同时运行进程数是有限的，在内存和cpu的限制下，如果有几千个进程同时运行，操作系统连调度都会出问题。

#多线程模式通常比多进程快一点，但也不是很明显。而且多线程模式最致命的缺点是任何一个线程挂掉，整个进程崩溃。因为所有
#的线程共享进程的内存。在window上，如果一个线程执行出问题，可以看到’该进程执行非法操作，即将关闭’，其实往往是某个
#线程出了错，但操作系统会强制整个进程终止。

#在window下，多线程的效率远高于多进程模式，所以微软的IIS服务器默认采用多线程模式。由于多线程存在稳定性的问题，IIS
#的稳定性就不如Apache。为了缓解这个问题，IIS和Apache现在出现多进程+多线程模式。

#线程切换：操作系统在切换进程或者线程时需要保存当前的执行环境（cpu寄存器状态，内存页等），然后，把新任务的执行
#环境准备好(恢复上次寄存器状态，切换内存页等)，才能开始执行。这个切换过程虽然很快，但是也需要耗时。如果同时有几
#千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了。这时很容易出现操作系统的‘假死’。

#1.计算密集型
#如果要进行大量的计算，消耗cpu资源，全靠cpu的运算能力。这种计算密集型任务虽然也可以使用多任务完成，但是任务越多，
#花费在切换任务的时间开销也就越高，cpu执行任务的效率也就越低。所以要高效的利用cpu，计算密集型的任务同时进行的数量
#应当等一cpu的核心数。计算密集型对cpu运算速度要求高，所以最好使用c语言等编译性语言实现。

#2.IO密集型
#涉及到网络，磁盘IO等任务都是IO密集型任务。这类任务cpu开销小，任务的大部分时间都在等待io操作完成。对于io密集型任务，
#任务数量越多，cpu效率越高，但也有一个限度。。场景的大部分任务都是io密集型的任务。IO密集型任务执行期间，99%的时间都
#花费在io上，花在cpu上的时间最少。因此，用运行速度快的c语言，替换python等解释型语言，完全无法提升效率。

#异步IO
#考虑到cpu和io之间巨大的速度差异，一个任务在执行的过程中大部分时间都在等待io操作，单进程单线程模型会导致别的任务无法
#并行执行，因此，需要多进程模型或者多线程模型来支持多任务的并发执行。
#使用异步io，就可以单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型，所以用异步io模型实现多任务也是比较好的
#在python中，单进程的异步编程模型称为协程。
