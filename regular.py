#!/usr/bin/env python3
#-*- encoding:utf-8 -*-

#正则表达式是一种用来匹配字符串的工具。其设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合
#规则的字符串，就认为匹配成功，否则该字符串就是不合法的。

#正则表达式也是用字符串描述的。

#精确匹配。
#用\d可以匹配一个数字
#\w可以匹配一个字母或数字
#‘.’可以匹配任意字符。
#若要匹配变长字符，在正则表达式中用'*'表示任意字符（包含0个），
#用'+'表示至少#一个字符，
#用'?'表示0个或1个字符，
#用'{n}'表示n个字符，
#用'{n,m}'表示n~m字符。
#'\s'表示空格.

#更精确的匹配
#可以使用[]表示范围，例如[0-9a-zA-z\_],可以匹配数字、字母以及下划线
#A|B表示可以匹配A或B，例如[P|p]ython可以匹配Python以及python
#^表示行的开头，^\d表示必须以数字开头
#$表示行的结束，\d$表示必须以数字结束

#example
s = "\d{3}\s+\d{3,8}" #\d{3},匹配3个数字；\s，匹配一个空格；\d{3,8},匹配3到8个数字

#python的re模块，包含所有正则表达式的功能。由于python的字符串本身也用'\'转义。
s = 'ABC\\-001' #'ABC\-001'
S = r'ABC\-001' #'ABC\-001',r前缀表示原始字符串，就不用考虑转义

import re
ret = re.match(r'^\d{3}\-\d{3,8}$','010-12345') #match匹配成功返回一个Match对象，否则返回None
print(ret) #success
ret = re.match(r'^\d{3}\-\d{3,8}$','010 12345')
print(ret) #failed

#切分字符串,用正则表达式切分字符串比用固定的字符更灵活。
l = 'ab c    d'.split(' ')
print(l) #['ab', 'c', '', '', '', 'd']
l = re.split(r'\s+','ab c    d')
print(l) #['ab', 'c', 'd']
l = re.split(r'[\s\,]+',"a,,b  c ,d")
print(l) #['a', 'b', 'c', 'd']

#分组,正则表达式提供提取子串的功能，用()表示的就是要提取分组。比如^(\d{3})-(\d{3,8})$
m = re.match(r'^(\d{3})-(\d{3,8})$','010-1234564')
print(m.group(0)) #010-1234564,group(0)永远是原始字符串
print(m.group(1)) #010
print(m.group(2)) #1234564

#贪婪匹配,正则表达式默认是贪婪匹配，也就是尽可能的匹配多的字符。
print(re.match(r'^(\d+)(0*)$','10003220').groups()) #('10003220', '')
#部分采用非贪婪匹配，加上'?'.
print(re.match(r'^(\d+?)(0*)$','10003220').groups()) #('1000322', '0')

#匹配过程：
#1.编译正则表达式，如果正则表达式的字符串本身不合法，报错；
#2.用编译后的字符串匹配字符串，为了效率，我们一般考虑预编译该正则表达式。
re_tele = re.compile(r'^(\d{3})\-(\d{3,8})$')
print(re_tele.match('010-12345').groups()) #('010', '12345')

#联系1:someone@gmail.com
ret = re.match(r'^[\d|\w]+\@gmail\.com','someone@gmail.com')
print(ret)
#联系2：tom@voyager.org
ret = re.match(r'^([\d|\w]+)\@voyager\.org','tom@voyager.org')
